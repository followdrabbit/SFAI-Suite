import os
import getpass
import asyncio
from utils.assistant_manager import OpenAIAssistantManager
from utils.files_manager import OpenAIFilesManager



api_key = "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"
assistant_manager = None
file_manager = None
assistants_data = {}
base_dir = "./data/lkb"

# Prepare data to write to .env file
assistants_info = {
    "BaselineSecurityExpert": {
        "instructions": "An assistant specialized in providing customized security recommendations for a wide range of AWS products. It should analyze the configuration and usage of each product, identify potential vulnerabilities, and recommend specific security controls, aligned with information security best practices, relevant compliance standards, and security frameworks. The assistant should offer guidance for continuous monitoring and incident response, relying on services like CloudWatch and AWS Security Hub, and stay updated on the latest security threats and vulnerabilities.",
        "tools": [{"type": "code_interpreter"}],
        "model": "gpt-3.5-turbo-16k"
    },
    "SecurityGuardianAI": {
        "instructions": "A specialized assistant for conducting detailed comparisons and critical analyses of security controls for AWS products, juxtaposing an organization's internal security policies and practices against security recommendations generated by other AI assistants. SecurityGuardianAI is designed to:\n\nAnalyze Documents and Recommendations:\nEvaluate both the organization's internal security documents and security recommendations generated by other assistants, focusing on AWS products. This includes proposed or implemented policies, procedures, and security controls.\n\nIdentify Discrepancies and Improvement Opportunities:\nDetect any internal security controls not addressed in external recommendations, as well as identify potential conflicts or redundancies between internal practices and assistant suggestions.\n\nRecommend Specific Actions:\nBased on the comparison, recommend adjustments to internal policies or the implementation of additional security controls, aligning internal practices with industry best practices, relevant compliance standards, and security frameworks.\n\nGuide Continuous Monitoring and Incident Response:\nProvide guidance for the continuous monitoring of AWS product security, using services like AWS CloudWatch and AWS Security Hub, and suggest practices for effective incident response.\n\nStay Updated on Security Threats:\nRemain informed about the latest security threats and vulnerabilities, ensuring that analyses and recommendations consider current and emerging cybersecurity trends.\n\nSecurityGuardianAI is designed to be a proactive tool in identifying gaps in an organization's security posture, promoting an evidence-based approach to strengthening security practices. It aims to facilitate informed decision-making on security risk management, leveraging in-depth analyses to ensure the integrity, confidentiality, and availability of AWS resources.",
        "tools": [
            {"type": "code_interpreter"},
            {"type": "retrieval"}
        ],
        "model": "gpt-4-0125-preview"
    }
}


async def create_new_assistants(assistant_manager, assistants_info):
    global assistants_data
    print("")
    print("#### Creating new assistants... ####")
    for assistant_name, assistant_info in assistants_info.items():
        assistant_id = await assistant_manager.create_assistant(
            assistant_name,
            assistant_info["instructions"],
            assistant_info["tools"],
            assistant_info["model"]
        )
        assistants_data[assistant_name] = assistant_id
        print(f"----> Done! The assistant '{assistant_name}' is set up and ready to assist with your security needs.")



def save_data_to_env_file(api_key, assistants_data):
    print("")
    print("#### Saving data... ####")
    file_path = ".env"
    with open(file_path, 'w') as file:
        file.write(f"OPENAI_API_KEY={api_key}\n")
        for assistant_name, assistant_id in assistants_data.items():
            file.write(f"{assistant_name.upper().replace(' ', '_')}_ID={assistant_id}\n")
    print("----> All settings have been successfully saved. You're all set to go!")


async def deletes_existent_env_file():
    print("")
    print("#### Checking for an existing configuration file... ####")
    if os.path.exists(".env"):
        os.remove(".env")
        print("----> The existing .env file has been successfully deleted.")
    else:
        print("----> No .env file has been found")


async def deletes_existents_assistants():
    try:
        print("")
        print("#### Checking existing assistants... ####")
        response = await assistant_manager.list_assistants()
        if response:
            for assistant in response.data:
                await assistant_manager.delete_assistant(assistant.id)
                print (f"----> Asssistant: {assistant.name} withID: {assistant.id} has been deleted successfully!")
        else:
            print()
    except Exception as e:
        print(f"Oops! Something went wrong. Here's the error message: {e}.")


async def deletes_existents_files():
    try:
        print("")
        print("#### Checking existing files... #####")
        files = await file_manager.list_files()
        if files:
            for file_object in files:
                await file_manager.delete_file(file_object.id)
                print(f"----> File: {file_object.filename} with ID: {file_object.id} has been deleted successfully!")

        else:
            print("No files has been found")
    except Exception as e:
        print(f"Oops! Something went wrong. Here's the error message: {e}.")

async def clear_existing_configs():
    try:
        await deletes_existent_env_file()
        await deletes_existents_assistants()
        await deletes_existents_files()

    except Exception as e:
        print(f"Oops! Something went wrong. Here's the error message: {e}.")

async def request_openai_api_key_to_user():
    global api_key
    try:
        while True:
            content = getpass.getpass("Enter the API key value (must start with 'sk-'): ")
            if content.startswith("sk-"):
                api_key = content
                return
            else:
                print("Error: API key must start with 'sk-'. Please try again.")
    except Exception as e:
        print(f"Oops! Something went wrong. Here's the error message: {e}.")

async def Instantiate_managers():
    global assistant_manager
    global file_manager
    try:
        assistant_manager = OpenAIAssistantManager(api_key) # Create an instance of OpenAIAssistantManager
        file_manager = OpenAIFilesManager(api_key) # Create an instance of OpenAIFilesManager
    except Exception as e:
        print (f"Error {e}")

async def upload_lkb_files_and_link_with_assistants():
    try:
        files = os.listdir(base_dir)
        if files:
            print("")
            print("#### Uploading and linking Local Knowledge base documents... ####")
            for filename in files:
                file_path = os.path.join(base_dir, filename)
                if os.path.isfile(file_path):
                    response = await file_manager.upload_file(file_path)
                    for assistant_name, assistant_id in assistants_data.items():
                        if assistant_name == "SecurityGuardianAI":
                            await assistant_manager.create_assistant_file(assistant_id, response.id)
                            print(f"----> File: {filename} uploaded and associated with SecurityGuardianAI")
        else:
            print("No files has been found")
    except Exception as e:
        print(f"Oops! Something went wrong. Here's the error message: {e}.")




async def main():
    await request_openai_api_key_to_user()
    await Instantiate_managers()
    await clear_existing_configs()
    await create_new_assistants(assistant_manager, assistants_info)
    await upload_lkb_files_and_link_with_assistants()
    save_data_to_env_file(api_key, assistants_data)


if __name__ == "__main__":
    asyncio.run(main())
